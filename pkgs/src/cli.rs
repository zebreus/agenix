//! Command-line argument parsing and definitions for agenix.
//!
//! This module defines the CLI interface using clap's derive macros with subcommands.

use clap::{CommandFactory, Parser, Subcommand};
use clap_complete::{Generator, Shell};
use std::env;
use std::io::{self, Write};

#[derive(Parser, Debug)]
#[command(
    version = env!("CARGO_PKG_VERSION"),
    about = "edit and rekey age secret files",
    after_help = concat!("agenix version: ", env!("CARGO_PKG_VERSION")),
    arg_required_else_help = true
)]
pub struct Args {
    /// Path to secrets.nix file (can also be set via SECRETS_NIX env var)
    #[arg(
        long = "secrets-nix",
        env = "SECRETS_NIX",
        value_name = "FILE",
        default_value = "./secrets.nix",
        global = true
    )]
    pub secrets_nix: String,

    /// Verbose output (show detailed information about operations)
    #[arg(short, long, global = true, conflicts_with = "quiet")]
    pub verbose: bool,

    /// Quiet output (suppress non-essential messages)
    #[arg(short, long, global = true, conflicts_with = "verbose")]
    pub quiet: bool,

    /// Dry-run mode (show what would be done without making changes)
    #[arg(short = 'n', long, global = true)]
    pub dry_run: bool,

    /// Identities to use when decrypting. Can be specified multiple times.
    /// Identities are tried in order: explicitly specified identities first, then default system identities.
    #[arg(short, long, value_name = "KEY", global = true, action = clap::ArgAction::Append)]
    pub identity: Vec<String>,

    /// Do not use default system identities (~/.ssh/id_rsa, ~/.ssh/id_ed25519)
    #[arg(long, global = true)]
    pub no_system_identities: bool,

    #[command(subcommand)]
    pub command: Option<Command>,
}

#[derive(Subcommand, Debug)]
pub enum Command {
    /// Edit or create a secret file interactively using $EDITOR
    #[command(visible_alias = "e")]
    Edit {
        /// The secret to edit
        #[arg(value_name = "SECRET", allow_hyphen_values = true)]
        file: String,

        /// Editor command to use (defaults to $EDITOR, or stdin when not a TTY, or vi)
        #[arg(short = 'e', long, env = "EDITOR", value_name = "COMMAND")]
        editor: Option<String>,

        /// Open empty editor if decryption fails (useful for recreating secrets)
        #[arg(short, long)]
        force: bool,

        /// Edit the public file (.pub) associated with the secret instead of the secret itself
        #[arg(short, long)]
        public: bool,
    },

    /// Encrypt content from stdin (or a file) to a secret file
    #[command(visible_alias = "c")]
    Encrypt {
        /// The secret to create
        #[arg(value_name = "SECRET", allow_hyphen_values = true)]
        file: String,

        /// Input file to read content from (defaults to stdin)
        #[arg(long, value_name = "FILE")]
        input: Option<String>,

        /// Overwrite existing secret file
        #[arg(short, long)]
        force: bool,

        /// Set the public file (.pub) associated with the secret instead of encrypting to the secret
        #[arg(short, long)]
        public: bool,
    },

    /// Decrypt a secret file to stdout or a file
    #[command(visible_alias = "d")]
    Decrypt {
        /// The secret to decrypt
        #[arg(value_name = "SECRET", allow_hyphen_values = true)]
        file: String,

        /// Output file (defaults to stdout)
        #[arg(short, long, value_name = "FILE")]
        output: Option<String>,

        /// Read the public file (.pub) associated with the secret instead of decrypting the secret
        #[arg(short, long)]
        public: bool,
    },

    /// Re-encrypt secrets with updated recipients
    #[command(visible_alias = "r")]
    Rekey {
        /// Allow partial rekeying: continue even if some secrets cannot be decrypted
        #[arg(short, long)]
        partial: bool,

        /// Secrets to rekey (if none specified, rekeys all secrets from secrets.nix)
        #[arg(value_name = "SECRET")]
        secrets: Vec<String>,
    },

    /// Generate secrets using generator functions from secrets.nix
    #[command(visible_alias = "g")]
    Generate {
        /// Overwrite existing secret files
        #[arg(short, long)]
        force: bool,

        /// Do not generate dependencies of specified secrets (dependencies are generated by default)
        #[arg(long)]
        no_dependencies: bool,

        /// Secrets to generate (if none specified, generates all secrets from secrets.nix)
        #[arg(value_name = "SECRET")]
        secrets: Vec<String>,
    },

    /// List secrets defined in secrets.nix
    #[command(visible_alias = "l")]
    List {
        /// Show status of each secret (ok/missing/cannot decrypt)
        #[arg(short, long)]
        status: bool,

        /// Secrets to list (if none specified, lists all secrets from secrets.nix)
        #[arg(value_name = "SECRET")]
        secrets: Vec<String>,
    },

    /// Verify that secrets can be decrypted without outputting content
    #[command(visible_alias = "v")]
    Check {
        /// Secrets to check (if none specified, checks all secrets from secrets.nix)
        #[arg(value_name = "SECRET")]
        secrets: Vec<String>,
    },

    /// Generate shell completions for the specified shell
    Completions {
        /// The shell to generate completions for
        #[arg(value_enum)]
        shell: Shell,
    },
}

/// Print shell completions to stdout
///
/// This function handles broken pipe errors gracefully, which can occur
/// when the output is piped to another command (e.g., `agenix completions fish | head`).
pub fn print_completions<G: Generator>(generator: G, cmd: &mut clap::Command) {
    let mut output = Vec::new();
    clap_complete::generate(generator, cmd, cmd.get_name().to_string(), &mut output);

    // Write to stdout, handling broken pipe gracefully
    if let Err(e) = io::stdout().write_all(&output) {
        // BrokenPipe is expected when piping to commands like `head`
        if e.kind() != io::ErrorKind::BrokenPipe {
            eprintln!("Error writing completions: {e}");
        }
    }
    // Flush stdout, ignoring broken pipe errors
    let _ = io::stdout().flush();
}

/// Get a mutable reference to the command for completions
pub fn build_cli() -> clap::Command {
    Args::command()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::{Mutex, OnceLock};

    static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();

    /// Helper to restore environment variable after test
    fn with_env_var<F>(key: &str, value: Option<&str>, f: F)
    where
        F: FnOnce(),
    {
        let _guard = ENV_LOCK.get_or_init(|| Mutex::new(())).lock().unwrap();
        let original = std::env::var(key).ok();

        match value {
            // SAFETY: We hold ENV_LOCK to ensure no other thread is accessing env vars
            Some(v) => unsafe { std::env::set_var(key, v) },
            None => unsafe { std::env::remove_var(key) },
        }

        f();

        match original {
            // SAFETY: We hold ENV_LOCK to ensure no other thread is accessing env vars
            Some(v) => unsafe { std::env::set_var(key, v) },
            None => unsafe { std::env::remove_var(key) },
        }
    }

    #[test]
    fn test_edit_subcommand() {
        let args = Args::try_parse_from(["agenix", "edit", "test.age"]).unwrap();
        assert!(matches!(args.command, Some(Command::Edit { .. })));
        assert!(!args.verbose);
        assert!(args.identity.is_empty());
        if let Some(Command::Edit { file, force, .. }) = args.command {
            assert_eq!(file, "test.age".to_string());
            assert!(!force);
        }
    }

    #[test]
    fn test_edit_short_alias() {
        let args = Args::try_parse_from(["agenix", "e", "test.age"]).unwrap();
        assert!(matches!(args.command, Some(Command::Edit { .. })));
    }

    #[test]
    fn test_edit_with_force() {
        let args = Args::try_parse_from(["agenix", "edit", "--force", "test.age"]).unwrap();
        if let Some(Command::Edit { file, force, .. }) = args.command {
            assert_eq!(file, "test.age".to_string());
            assert!(force);
        } else {
            panic!("Expected Edit command");
        }
    }

    #[test]
    fn test_edit_with_force_short() {
        let args = Args::try_parse_from(["agenix", "edit", "-f", "test.age"]).unwrap();
        if let Some(Command::Edit { file, force, .. }) = args.command {
            assert_eq!(file, "test.age".to_string());
            assert!(force);
        } else {
            panic!("Expected Edit command");
        }
    }

    #[test]
    fn test_edit_with_dry_run() {
        let args = Args::try_parse_from(["agenix", "--dry-run", "edit", "test.age"]).unwrap();
        if let Some(Command::Edit { file, .. }) = args.command {
            assert_eq!(file, "test.age".to_string());
            assert!(args.dry_run);
        } else {
            panic!("Expected Edit command");
        }
    }

    #[test]
    fn test_edit_with_dry_run_short() {
        let args = Args::try_parse_from(["agenix", "-n", "edit", "test.age"]).unwrap();
        if let Some(Command::Edit { file, .. }) = args.command {
            assert_eq!(file, "test.age".to_string());
            assert!(args.dry_run);
        } else {
            panic!("Expected Edit command");
        }
    }

    #[test]
    fn test_rekey_subcommand() {
        let args = Args::try_parse_from(["agenix", "rekey"]).unwrap();
        assert!(matches!(args.command, Some(Command::Rekey { .. })));
    }

    #[test]
    fn test_rekey_short_alias() {
        let args = Args::try_parse_from(["agenix", "r"]).unwrap();
        assert!(matches!(args.command, Some(Command::Rekey { .. })));
    }

    #[test]
    fn test_decrypt_subcommand_with_identity() {
        let args = Args::try_parse_from(["agenix", "-i", "/path/to/key", "decrypt", "secret.age"])
            .unwrap();
        assert_eq!(args.identity, vec!["/path/to/key".to_string()]);
        if let Some(Command::Decrypt { file, .. }) = args.command {
            assert_eq!(file, "secret.age".to_string());
        } else {
            panic!("Expected Decrypt command");
        }
    }

    #[test]
    fn test_decrypt_short_alias() {
        let args = Args::try_parse_from(["agenix", "d", "secret.age"]).unwrap();
        assert!(matches!(args.command, Some(Command::Decrypt { .. })));
    }

    #[test]
    fn test_encrypt_subcommand() {
        let args = Args::try_parse_from(["agenix", "encrypt", "test.age"]).unwrap();
        assert!(matches!(args.command, Some(Command::Encrypt { .. })));
        if let Some(Command::Encrypt {
            file, input, force, ..
        }) = args.command
        {
            assert_eq!(file, "test.age".to_string());
            assert!(input.is_none());
            assert!(!force);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    #[test]
    fn test_encrypt_short_alias() {
        let args = Args::try_parse_from(["agenix", "c", "test.age"]).unwrap();
        assert!(matches!(args.command, Some(Command::Encrypt { .. })));
    }

    #[test]
    fn test_encrypt_with_force() {
        let args = Args::try_parse_from(["agenix", "encrypt", "--force", "test.age"]).unwrap();
        if let Some(Command::Encrypt {
            file, input, force, ..
        }) = args.command
        {
            assert_eq!(file, "test.age".to_string());
            assert!(input.is_none());
            assert!(force);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    #[test]
    fn test_encrypt_with_force_short() {
        let args = Args::try_parse_from(["agenix", "encrypt", "-f", "test.age"]).unwrap();
        if let Some(Command::Encrypt {
            file, input, force, ..
        }) = args.command
        {
            assert_eq!(file, "test.age".to_string());
            assert!(input.is_none());
            assert!(force);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    #[test]
    fn test_encrypt_with_input_file() {
        let args = Args::try_parse_from([
            "agenix",
            "encrypt",
            "--input",
            "/path/to/input.txt",
            "test.age",
        ])
        .unwrap();
        if let Some(Command::Encrypt {
            file, input, force, ..
        }) = args.command
        {
            assert_eq!(file, "test.age".to_string());
            assert_eq!(input, Some("/path/to/input.txt".to_string()));
            assert!(!force);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    #[test]
    fn test_encrypt_with_input_short() {
        // Note: --input doesn't have a short flag because -i is used by global --identity
        let args = Args::try_parse_from([
            "agenix",
            "encrypt",
            "--input",
            "/path/to/input.txt",
            "test.age",
        ])
        .unwrap();
        if let Some(Command::Encrypt {
            file, input, force, ..
        }) = args.command
        {
            assert_eq!(file, "test.age".to_string());
            assert_eq!(input, Some("/path/to/input.txt".to_string()));
            assert!(!force);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    #[test]
    fn test_encrypt_with_input_and_force() {
        let args = Args::try_parse_from([
            "agenix",
            "encrypt",
            "--input",
            "/path/to/input.txt",
            "-f",
            "test.age",
        ])
        .unwrap();
        if let Some(Command::Encrypt {
            file, input, force, ..
        }) = args.command
        {
            assert_eq!(file, "test.age".to_string());
            assert_eq!(input, Some("/path/to/input.txt".to_string()));
            assert!(force);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    #[test]
    fn test_verbose_flag_with_edit() {
        let args = Args::try_parse_from(["agenix", "-v", "edit", "test.age"]).unwrap();
        assert!(args.verbose);
        assert!(matches!(args.command, Some(Command::Edit { .. })));
    }

    #[test]
    fn test_verbose_flag_after_subcommand() {
        let args = Args::try_parse_from(["agenix", "edit", "-v", "test.age"]).unwrap();
        assert!(args.verbose);
        assert!(matches!(args.command, Some(Command::Edit { .. })));
    }

    #[test]
    fn test_args_parsing_default_editor() {
        with_env_var("EDITOR", None, || {
            let args = Args::try_parse_from(["agenix", "edit", "test.age"]).unwrap();
            if let Some(Command::Edit { file, editor, .. }) = args.command {
                assert_eq!(file, "test.age".to_string());
                assert_eq!(editor, None);
            } else {
                panic!("Expected Edit command");
            }
        });
    }

    #[test]
    fn test_editor_env_overrides_default() {
        with_env_var("EDITOR", Some("nano"), || {
            let args = Args::try_parse_from(["agenix", "edit", "test.age"]).unwrap();
            if let Some(Command::Edit { editor, .. }) = args.command {
                assert_eq!(editor, Some("nano".to_string()));
            } else {
                panic!("Expected Edit command");
            }
        });
    }

    #[test]
    fn test_editor_flag_overrides_env() {
        with_env_var("EDITOR", Some("nano"), || {
            let args =
                Args::try_parse_from(["agenix", "edit", "--editor", "vim", "test.age"]).unwrap();
            if let Some(Command::Edit { editor, .. }) = args.command {
                assert_eq!(editor, Some("vim".to_string()));
            } else {
                panic!("Expected Edit command");
            }
        });
    }

    #[test]
    fn test_editor_flag_without_env() {
        with_env_var("EDITOR", None, || {
            let args =
                Args::try_parse_from(["agenix", "edit", "--editor", "micro", "test.age"]).unwrap();
            if let Some(Command::Edit { editor, .. }) = args.command {
                assert_eq!(editor, Some("micro".to_string()));
            } else {
                panic!("Expected Edit command");
            }
        });
    }

    #[test]
    fn test_secrets_nix_env_var() {
        with_env_var("SECRETS_NIX", Some("/custom/path/secrets.nix"), || {
            let args = Args::try_parse_from(["agenix", "generate"]).unwrap();
            assert_eq!(args.secrets_nix, "/custom/path/secrets.nix");
        });
    }

    #[test]
    fn test_generate_subcommand() {
        let args = Args::try_parse_from(["agenix", "generate"]).unwrap();
        assert!(matches!(args.command, Some(Command::Generate { .. })));
        if let Some(Command::Generate {
            force,
            no_dependencies,
            secrets,
        }) = args.command
        {
            assert!(!force);
            assert!(!args.dry_run);
            assert!(!no_dependencies);
            assert!(secrets.is_empty());
        }
    }

    #[test]
    fn test_generate_short_alias() {
        let args = Args::try_parse_from(["agenix", "g"]).unwrap();
        assert!(matches!(args.command, Some(Command::Generate { .. })));
    }

    #[test]
    fn test_generate_force_flag() {
        let args = Args::try_parse_from(["agenix", "generate", "--force"]).unwrap();
        if let Some(Command::Generate {
            force,
            no_dependencies,
            secrets,
        }) = args.command
        {
            assert!(force);
            assert!(!args.dry_run);
            assert!(!no_dependencies);
            assert!(secrets.is_empty());
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_force_short_flag() {
        let args = Args::try_parse_from(["agenix", "generate", "-f"]).unwrap();
        if let Some(Command::Generate { force, .. }) = args.command {
            assert!(force);
            assert!(!args.dry_run);
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_dry_run_flag() {
        let args = Args::try_parse_from(["agenix", "--dry-run", "generate"]).unwrap();
        if let Some(Command::Generate { force, .. }) = args.command {
            assert!(!force);
            assert!(args.dry_run);
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_dry_run_short_flag() {
        let args = Args::try_parse_from(["agenix", "-n", "generate"]).unwrap();
        if let Some(Command::Generate { force, .. }) = args.command {
            assert!(!force);
            assert!(args.dry_run);
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_force_and_dry_run() {
        let args = Args::try_parse_from(["agenix", "--dry-run", "generate", "--force"]).unwrap();
        if let Some(Command::Generate { force, .. }) = args.command {
            assert!(force);
            assert!(args.dry_run);
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_short_flags_combined() {
        let args = Args::try_parse_from(["agenix", "-n", "generate", "-f"]).unwrap();
        if let Some(Command::Generate { force, .. }) = args.command {
            assert!(force);
            assert!(args.dry_run);
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_help_contains_version() {
        use clap::CommandFactory;

        let mut cmd = Args::command();
        let help = cmd.render_help().to_string();

        // Check that help contains the version information at the end
        let expected_version_line = format!("agenix version: {}", env!("CARGO_PKG_VERSION"));
        assert!(
            help.contains(&expected_version_line),
            "Help output should contain version line: {expected_version_line}",
        );

        // Also verify it's near the end (after the Commands section)
        let commands_pos = help
            .find("Commands:")
            .expect("Help should contain Commands section");
        let version_pos = help
            .find(&expected_version_line)
            .expect("Help should contain version line");
        assert!(
            version_pos > commands_pos,
            "Version line should appear after Commands section"
        );
    }

    #[test]
    fn test_no_subcommand_shows_help() {
        // With arg_required_else_help, running with no arguments should error
        let result = Args::try_parse_from(["agenix"]);
        assert!(result.is_err(), "No subcommand should trigger help display");
    }

    #[test]
    fn test_global_flags_alone_still_need_subcommand() {
        // Global flags like -v still work but the command is None
        // When run via actual binary, arg_required_else_help shows help and exits
        // With try_parse_from, it returns Ok but with command = None
        let result = Args::try_parse_from(["agenix", "-v"]);
        // This parses successfully but with no command
        assert!(result.is_ok());
        let args = result.unwrap();
        assert!(args.command.is_none());
        assert!(args.verbose);
    }

    #[test]
    fn test_decrypt_with_output() {
        let args =
            Args::try_parse_from(["agenix", "decrypt", "secret.age", "-o", "/path/to/output"])
                .unwrap();
        if let Some(Command::Decrypt { file, output, .. }) = args.command {
            assert_eq!(file, "secret.age".to_string());
            assert_eq!(output, Some("/path/to/output".to_string()));
        } else {
            panic!("Expected Decrypt command");
        }
    }

    #[test]
    fn test_global_secrets_nix_option() {
        let args =
            Args::try_parse_from(["agenix", "--secrets-nix", "/custom/secrets.nix", "generate"])
                .unwrap();
        assert_eq!(args.secrets_nix, "/custom/secrets.nix");
        assert!(matches!(args.command, Some(Command::Generate { .. })));
    }

    #[test]
    fn test_edit_editor_short_flag() {
        let args = Args::try_parse_from(["agenix", "edit", "-e", "nano", "test.age"]).unwrap();
        if let Some(Command::Edit { editor, .. }) = args.command {
            assert_eq!(editor, Some("nano".to_string()));
        } else {
            panic!("Expected Edit command");
        }
    }

    // Tests to ensure old flag-based interface no longer works
    // These verify that the migration to subcommands is complete

    #[test]
    fn test_old_edit_flag_rejected() {
        // Old: agenix -e file.age
        // New: agenix edit file.age
        let result = Args::try_parse_from(["agenix", "-e", "test.age"]);
        assert!(result.is_err(), "Old -e flag should be rejected");
    }

    #[test]
    fn test_old_edit_long_flag_rejected() {
        // Old: agenix --edit file.age
        let result = Args::try_parse_from(["agenix", "--edit", "test.age"]);
        assert!(result.is_err(), "Old --edit flag should be rejected");
    }

    #[test]
    fn test_old_decrypt_flag_rejected() {
        // Old: agenix -d file.age
        // New: agenix decrypt file.age
        let result = Args::try_parse_from(["agenix", "-d", "test.age"]);
        assert!(result.is_err(), "Old -d flag should be rejected");
    }

    #[test]
    fn test_old_decrypt_long_flag_rejected() {
        // Old: agenix --decrypt file.age
        let result = Args::try_parse_from(["agenix", "--decrypt", "test.age"]);
        assert!(result.is_err(), "Old --decrypt flag should be rejected");
    }

    #[test]
    fn test_old_rekey_long_flag_rejected() {
        // Old: agenix --rekey
        let result = Args::try_parse_from(["agenix", "--rekey"]);
        assert!(result.is_err(), "Old --rekey flag should be rejected");
    }

    #[test]
    fn test_old_generate_flag_rejected() {
        // Old: agenix -g
        // New: agenix generate
        let result = Args::try_parse_from(["agenix", "-g"]);
        assert!(result.is_err(), "Old -g flag should be rejected");
    }

    #[test]
    fn test_old_generate_long_flag_rejected() {
        // Old: agenix --generate
        let result = Args::try_parse_from(["agenix", "--generate"]);
        assert!(result.is_err(), "Old --generate flag should be rejected");
    }

    #[test]
    fn test_global_identity_flag_at_root_works() {
        // Now: agenix -i key edit file.age (identity at root level works)
        let result = Args::try_parse_from(["agenix", "-i", "/path/to/key", "edit", "test.age"]);
        assert!(
            result.is_ok(),
            "Global -i flag at root level should be accepted"
        );
        let args = result.unwrap();
        assert_eq!(args.identity, vec!["/path/to/key".to_string()]);
    }

    #[test]
    fn test_old_output_flag_at_root_rejected() {
        // Old: agenix -o output -d file.age (output at root level)
        // New: agenix decrypt -o output file.age (output in subcommand)
        let result = Args::try_parse_from(["agenix", "-o", "output.txt", "decrypt", "test.age"]);
        assert!(
            result.is_err(),
            "Old -o flag at root level should be rejected"
        );
    }

    // Tests for global identity flag - only essential coverage

    #[test]
    fn test_identity_before_subcommand() {
        let args =
            Args::try_parse_from(["agenix", "-i", "/path/to/key", "edit", "secret.age"]).unwrap();
        assert_eq!(args.identity, vec!["/path/to/key".to_string()]);
        assert!(matches!(args.command, Some(Command::Edit { .. })));
    }

    #[test]
    fn test_identity_after_subcommand() {
        let args = Args::try_parse_from(["agenix", "decrypt", "-i", "/path/to/key", "secret.age"])
            .unwrap();
        assert_eq!(args.identity, vec!["/path/to/key".to_string()]);
        assert!(matches!(args.command, Some(Command::Decrypt { .. })));
    }

    #[test]
    fn test_multiple_identities_order_preserved() {
        let args = Args::try_parse_from([
            "agenix",
            "-i",
            "/first",
            "-i",
            "/second",
            "-i",
            "/third",
            "decrypt",
            "secret.age",
        ])
        .unwrap();
        assert_eq!(
            args.identity,
            vec![
                "/first".to_string(),
                "/second".to_string(),
                "/third".to_string()
            ]
        );
    }

    #[test]
    fn test_no_system_identities_flag() {
        let args =
            Args::try_parse_from(["agenix", "--no-system-identities", "decrypt", "secret.age"])
                .unwrap();
        assert!(args.no_system_identities);
    }

    #[test]
    fn test_identity_with_no_system_identities_combined() {
        let args = Args::try_parse_from([
            "agenix",
            "-i",
            "/key1",
            "--no-system-identities",
            "decrypt",
            "secret.age",
        ])
        .unwrap();
        assert_eq!(args.identity, vec!["/key1".to_string()]);
        assert!(args.no_system_identities);
    }

    // Tests for positional secrets argument in rekey

    #[test]
    fn test_rekey_with_positional_secrets() {
        let args = Args::try_parse_from(["agenix", "rekey", "secret1.age", "secret2.age"]).unwrap();
        if let Some(Command::Rekey { secrets, .. }) = args.command {
            assert_eq!(
                secrets,
                vec!["secret1.age".to_string(), "secret2.age".to_string()]
            );
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_rekey_without_positional_secrets() {
        let args = Args::try_parse_from(["agenix", "rekey"]).unwrap();
        if let Some(Command::Rekey { secrets, .. }) = args.command {
            assert!(secrets.is_empty());
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_rekey_single_secret() {
        let args = Args::try_parse_from(["agenix", "rekey", "single.age"]).unwrap();
        if let Some(Command::Rekey { secrets, .. }) = args.command {
            assert_eq!(secrets, vec!["single.age".to_string()]);
        } else {
            panic!("Expected Rekey command");
        }
    }

    // Tests for positional secrets argument in generate

    #[test]
    fn test_generate_with_positional_secrets() {
        let args =
            Args::try_parse_from(["agenix", "generate", "secret1.age", "secret2.age"]).unwrap();
        if let Some(Command::Generate { secrets, .. }) = args.command {
            assert_eq!(
                secrets,
                vec!["secret1.age".to_string(), "secret2.age".to_string()]
            );
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_without_positional_secrets() {
        let args = Args::try_parse_from(["agenix", "generate"]).unwrap();
        if let Some(Command::Generate { secrets, .. }) = args.command {
            assert!(secrets.is_empty());
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_single_secret() {
        let args = Args::try_parse_from(["agenix", "generate", "single.age"]).unwrap();
        if let Some(Command::Generate { secrets, .. }) = args.command {
            assert_eq!(secrets, vec!["single.age".to_string()]);
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_no_dependencies_flag() {
        let args = Args::try_parse_from(["agenix", "generate", "--no-dependencies", "secret.age"])
            .unwrap();
        if let Some(Command::Generate {
            no_dependencies,
            secrets,
            ..
        }) = args.command
        {
            assert!(no_dependencies);
            assert_eq!(secrets, vec!["secret.age".to_string()]);
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_with_flags_and_positional_secrets() {
        let args = Args::try_parse_from([
            "agenix",
            "--dry-run",
            "generate",
            "--force",
            "secret1.age",
            "secret2.age",
        ])
        .unwrap();
        if let Some(Command::Generate { force, secrets, .. }) = args.command {
            assert!(force);
            assert!(args.dry_run);
            assert_eq!(
                secrets,
                vec!["secret1.age".to_string(), "secret2.age".to_string()]
            );
        } else {
            panic!("Expected Generate command");
        }
    }

    #[test]
    fn test_generate_secrets_after_flags() {
        let args = Args::try_parse_from([
            "agenix",
            "-n",
            "generate",
            "-f",
            "--no-dependencies",
            "a.age",
            "b.age",
        ])
        .unwrap();
        if let Some(Command::Generate {
            force,
            no_dependencies,
            secrets,
        }) = args.command
        {
            assert!(force);
            assert!(args.dry_run);
            assert!(no_dependencies);
            assert_eq!(secrets, vec!["a.age".to_string(), "b.age".to_string()]);
        } else {
            panic!("Expected Generate command");
        }
    }

    // Tests for rekey --partial flag

    #[test]
    fn test_rekey_partial_flag() {
        let args = Args::try_parse_from(["agenix", "rekey", "--partial"]).unwrap();
        if let Some(Command::Rekey {
            partial, secrets, ..
        }) = args.command
        {
            assert!(partial);
            assert!(secrets.is_empty());
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_rekey_partial_short_flag() {
        let args = Args::try_parse_from(["agenix", "rekey", "-p"]).unwrap();
        if let Some(Command::Rekey {
            partial, secrets, ..
        }) = args.command
        {
            assert!(partial);
            assert!(secrets.is_empty());
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_rekey_partial_with_secrets() {
        let args =
            Args::try_parse_from(["agenix", "rekey", "--partial", "secret1.age", "secret2.age"])
                .unwrap();
        if let Some(Command::Rekey {
            partial, secrets, ..
        }) = args.command
        {
            assert!(partial);
            assert_eq!(
                secrets,
                vec!["secret1.age".to_string(), "secret2.age".to_string()]
            );
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_rekey_default_not_partial() {
        let args = Args::try_parse_from(["agenix", "rekey"]).unwrap();
        if let Some(Command::Rekey {
            partial, secrets, ..
        }) = args.command
        {
            assert!(!partial);
            assert!(secrets.is_empty());
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_rekey_dry_run_flag() {
        let args = Args::try_parse_from(["agenix", "--dry-run", "rekey"]).unwrap();
        if let Some(Command::Rekey { .. }) = args.command {
            assert!(args.dry_run);
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_rekey_dry_run_short_flag() {
        let args = Args::try_parse_from(["agenix", "-n", "rekey"]).unwrap();
        if let Some(Command::Rekey { .. }) = args.command {
            assert!(args.dry_run);
        } else {
            panic!("Expected Rekey command");
        }
    }

    #[test]
    fn test_encrypt_dry_run_flag() {
        let args = Args::try_parse_from(["agenix", "--dry-run", "encrypt", "test.age"]).unwrap();
        if let Some(Command::Encrypt { .. }) = args.command {
            assert!(args.dry_run);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    #[test]
    fn test_encrypt_dry_run_short_flag() {
        let args = Args::try_parse_from(["agenix", "-n", "encrypt", "test.age"]).unwrap();
        if let Some(Command::Encrypt { .. }) = args.command {
            assert!(args.dry_run);
        } else {
            panic!("Expected Encrypt command");
        }
    }

    // ===========================================
    // LIST COMMAND CLI TESTS (10+ tests)
    // ===========================================

    #[test]
    fn test_list_subcommand() {
        let args = Args::try_parse_from(["agenix", "list"]).unwrap();
        assert!(matches!(args.command, Some(Command::List { .. })));
        if let Some(Command::List { status, secrets }) = args.command {
            assert!(!status);
            assert!(secrets.is_empty());
        }
    }

    #[test]
    fn test_list_short_alias() {
        let args = Args::try_parse_from(["agenix", "l"]).unwrap();
        assert!(matches!(args.command, Some(Command::List { .. })));
    }

    #[test]
    fn test_list_status_flag() {
        let args = Args::try_parse_from(["agenix", "list", "--status"]).unwrap();
        if let Some(Command::List { status, secrets }) = args.command {
            assert!(status);
            assert!(secrets.is_empty());
        } else {
            panic!("Expected List command");
        }
    }

    #[test]
    fn test_list_status_short_flag() {
        let args = Args::try_parse_from(["agenix", "list", "-s"]).unwrap();
        if let Some(Command::List { status, secrets }) = args.command {
            assert!(status);
            assert!(secrets.is_empty());
        } else {
            panic!("Expected List command");
        }
    }

    #[test]
    fn test_list_with_secrets() {
        let args = Args::try_parse_from(["agenix", "list", "secret1.age", "secret2.age"]).unwrap();
        if let Some(Command::List { status, secrets }) = args.command {
            assert!(!status);
            assert_eq!(
                secrets,
                vec!["secret1.age".to_string(), "secret2.age".to_string()]
            );
        } else {
            panic!("Expected List command");
        }
    }

    #[test]
    fn test_list_with_status_and_secrets() {
        let args =
            Args::try_parse_from(["agenix", "list", "--status", "secret1.age", "secret2.age"])
                .unwrap();
        if let Some(Command::List { status, secrets }) = args.command {
            assert!(status);
            assert_eq!(
                secrets,
                vec!["secret1.age".to_string(), "secret2.age".to_string()]
            );
        } else {
            panic!("Expected List command");
        }
    }

    #[test]
    fn test_list_with_secrets_nix_flag() {
        let args = Args::try_parse_from(["agenix", "--secrets-nix", "/custom/secrets.nix", "list"])
            .unwrap();
        assert_eq!(args.secrets_nix, "/custom/secrets.nix");
        assert!(matches!(args.command, Some(Command::List { .. })));
    }

    #[test]
    fn test_list_with_identity_flag() {
        let args = Args::try_parse_from(["agenix", "-i", "/path/to/key", "list"]).unwrap();
        assert_eq!(args.identity, vec!["/path/to/key".to_string()]);
        if let Some(Command::List { status, secrets }) = args.command {
            assert!(!status);
            assert!(secrets.is_empty());
        } else {
            panic!("Expected List command");
        }
    }

    #[test]
    fn test_list_with_no_system_identities() {
        let args = Args::try_parse_from(["agenix", "--no-system-identities", "list"]).unwrap();
        assert!(args.no_system_identities);
        assert!(matches!(args.command, Some(Command::List { .. })));
    }

    #[test]
    fn test_list_with_verbose_flag() {
        let args = Args::try_parse_from(["agenix", "-v", "list"]).unwrap();
        assert!(args.verbose);
        assert!(matches!(args.command, Some(Command::List { .. })));
    }

    #[test]
    fn test_list_verbose_after_subcommand() {
        let args = Args::try_parse_from(["agenix", "list", "-v"]).unwrap();
        assert!(args.verbose);
        assert!(matches!(args.command, Some(Command::List { .. })));
    }

    #[test]
    fn test_list_all_flags_combined() {
        let args = Args::try_parse_from([
            "agenix",
            "-v",
            "--secrets-nix",
            "/secrets.nix",
            "-i",
            "/key",
            "--no-system-identities",
            "list",
            "--status",
            "secret1.age",
        ])
        .unwrap();
        assert!(args.verbose);
        assert_eq!(args.secrets_nix, "/secrets.nix");
        assert_eq!(args.identity, vec!["/key".to_string()]);
        assert!(args.no_system_identities);
        if let Some(Command::List { status, secrets }) = args.command {
            assert!(status);
            assert_eq!(secrets, vec!["secret1.age".to_string()]);
        } else {
            panic!("Expected List command");
        }
    }

    // ===========================================
    // CHECK COMMAND CLI TESTS (10+ tests)
    // ===========================================

    #[test]
    fn test_check_subcommand() {
        let args = Args::try_parse_from(["agenix", "check"]).unwrap();
        assert!(matches!(args.command, Some(Command::Check { .. })));
        if let Some(Command::Check { secrets }) = args.command {
            assert!(secrets.is_empty());
        }
    }

    #[test]
    fn test_check_short_alias() {
        let args = Args::try_parse_from(["agenix", "v"]).unwrap();
        assert!(matches!(args.command, Some(Command::Check { .. })));
    }

    #[test]
    fn test_check_single_secret() {
        let args = Args::try_parse_from(["agenix", "check", "secret1.age"]).unwrap();
        if let Some(Command::Check { secrets }) = args.command {
            assert_eq!(secrets, vec!["secret1.age".to_string()]);
        } else {
            panic!("Expected Check command");
        }
    }

    #[test]
    fn test_check_multiple_secrets() {
        let args = Args::try_parse_from([
            "agenix",
            "check",
            "secret1.age",
            "secret2.age",
            "secret3.age",
        ])
        .unwrap();
        if let Some(Command::Check { secrets }) = args.command {
            assert_eq!(
                secrets,
                vec![
                    "secret1.age".to_string(),
                    "secret2.age".to_string(),
                    "secret3.age".to_string()
                ]
            );
        } else {
            panic!("Expected Check command");
        }
    }

    #[test]
    fn test_check_with_secrets_nix_flag() {
        let args =
            Args::try_parse_from(["agenix", "--secrets-nix", "/custom/secrets.nix", "check"])
                .unwrap();
        assert_eq!(args.secrets_nix, "/custom/secrets.nix");
        assert!(matches!(args.command, Some(Command::Check { .. })));
    }

    #[test]
    fn test_check_with_identity_flag() {
        let args =
            Args::try_parse_from(["agenix", "-i", "/path/to/key", "check", "secret.age"]).unwrap();
        assert_eq!(args.identity, vec!["/path/to/key".to_string()]);
        if let Some(Command::Check { secrets }) = args.command {
            assert_eq!(secrets, vec!["secret.age".to_string()]);
        } else {
            panic!("Expected Check command");
        }
    }

    #[test]
    fn test_check_with_multiple_identities() {
        let args = Args::try_parse_from([
            "agenix",
            "-i",
            "/key1",
            "-i",
            "/key2",
            "check",
            "secret.age",
        ])
        .unwrap();
        assert_eq!(
            args.identity,
            vec!["/key1".to_string(), "/key2".to_string()]
        );
    }

    #[test]
    fn test_check_with_no_system_identities() {
        let args = Args::try_parse_from(["agenix", "--no-system-identities", "check"]).unwrap();
        assert!(args.no_system_identities);
        assert!(matches!(args.command, Some(Command::Check { .. })));
    }

    #[test]
    fn test_check_with_verbose_flag() {
        let args = Args::try_parse_from(["agenix", "-v", "check"]).unwrap();
        assert!(args.verbose);
        assert!(matches!(args.command, Some(Command::Check { .. })));
    }

    #[test]
    fn test_check_verbose_after_subcommand() {
        let args = Args::try_parse_from(["agenix", "check", "-v", "secret.age"]).unwrap();
        assert!(args.verbose);
        if let Some(Command::Check { secrets }) = args.command {
            assert_eq!(secrets, vec!["secret.age".to_string()]);
        } else {
            panic!("Expected Check command");
        }
    }

    #[test]
    fn test_check_all_flags_combined() {
        let args = Args::try_parse_from([
            "agenix",
            "-v",
            "--secrets-nix",
            "/secrets.nix",
            "-i",
            "/key",
            "--no-system-identities",
            "check",
            "secret1.age",
            "secret2.age",
        ])
        .unwrap();
        assert!(args.verbose);
        assert_eq!(args.secrets_nix, "/secrets.nix");
        assert_eq!(args.identity, vec!["/key".to_string()]);
        assert!(args.no_system_identities);
        if let Some(Command::Check { secrets }) = args.command {
            assert_eq!(
                secrets,
                vec!["secret1.age".to_string(), "secret2.age".to_string()]
            );
        } else {
            panic!("Expected Check command");
        }
    }

    // ===========================================
    // COMPLETIONS COMMAND CLI TESTS (10+ tests)
    // ===========================================

    #[test]
    fn test_completions_bash() {
        let args = Args::try_parse_from(["agenix", "completions", "bash"]).unwrap();
        if let Some(Command::Completions { shell }) = args.command {
            assert_eq!(shell, Shell::Bash);
        } else {
            panic!("Expected Completions command");
        }
    }

    #[test]
    fn test_completions_zsh() {
        let args = Args::try_parse_from(["agenix", "completions", "zsh"]).unwrap();
        if let Some(Command::Completions { shell }) = args.command {
            assert_eq!(shell, Shell::Zsh);
        } else {
            panic!("Expected Completions command");
        }
    }

    #[test]
    fn test_completions_fish() {
        let args = Args::try_parse_from(["agenix", "completions", "fish"]).unwrap();
        if let Some(Command::Completions { shell }) = args.command {
            assert_eq!(shell, Shell::Fish);
        } else {
            panic!("Expected Completions command");
        }
    }

    #[test]
    fn test_completions_elvish() {
        let args = Args::try_parse_from(["agenix", "completions", "elvish"]).unwrap();
        if let Some(Command::Completions { shell }) = args.command {
            assert_eq!(shell, Shell::Elvish);
        } else {
            panic!("Expected Completions command");
        }
    }

    #[test]
    fn test_completions_powershell() {
        let args = Args::try_parse_from(["agenix", "completions", "powershell"]).unwrap();
        if let Some(Command::Completions { shell }) = args.command {
            assert_eq!(shell, Shell::PowerShell);
        } else {
            panic!("Expected Completions command");
        }
    }

    #[test]
    fn test_completions_invalid_shell() {
        let result = Args::try_parse_from(["agenix", "completions", "invalidshell"]);
        assert!(result.is_err(), "Should reject invalid shell name");
    }

    #[test]
    fn test_completions_missing_shell() {
        let result = Args::try_parse_from(["agenix", "completions"]);
        assert!(result.is_err(), "Should require shell argument");
    }

    #[test]
    fn test_completions_case_sensitive() {
        // Shell names should be lowercase
        let result = Args::try_parse_from(["agenix", "completions", "BASH"]);
        assert!(result.is_err(), "Shell names should be case-sensitive");
    }

    #[test]
    fn test_completions_with_secrets_nix_flag() {
        // Global flags should work but are ignored for completions
        let args = Args::try_parse_from([
            "agenix",
            "--secrets-nix",
            "/custom/secrets.nix",
            "completions",
            "bash",
        ])
        .unwrap();
        assert_eq!(args.secrets_nix, "/custom/secrets.nix");
        if let Some(Command::Completions { shell }) = args.command {
            assert_eq!(shell, Shell::Bash);
        } else {
            panic!("Expected Completions command");
        }
    }

    #[test]
    fn test_completions_with_verbose() {
        let args = Args::try_parse_from(["agenix", "-v", "completions", "zsh"]).unwrap();
        assert!(args.verbose);
        if let Some(Command::Completions { shell }) = args.command {
            assert_eq!(shell, Shell::Zsh);
        } else {
            panic!("Expected Completions command");
        }
    }

    #[test]
    fn test_completions_extra_args_rejected() {
        // Completions should not accept extra arguments after the shell
        let result = Args::try_parse_from(["agenix", "completions", "bash", "extra-arg"]);
        assert!(result.is_err(), "Should reject extra arguments");
    }

    // ===========================================
    // QUIET FLAG TESTS
    // ===========================================

    #[test]
    fn test_quiet_flag() {
        let args = Args::try_parse_from(["agenix", "-q", "list"]).unwrap();
        assert!(args.quiet);
        assert!(!args.verbose);
    }

    #[test]
    fn test_quiet_long_flag() {
        let args = Args::try_parse_from(["agenix", "--quiet", "list"]).unwrap();
        assert!(args.quiet);
        assert!(!args.verbose);
    }

    #[test]
    fn test_quiet_after_subcommand() {
        let args = Args::try_parse_from(["agenix", "list", "-q"]).unwrap();
        assert!(args.quiet);
        assert!(matches!(args.command, Some(Command::List { .. })));
    }

    #[test]
    fn test_quiet_with_decrypt() {
        let args = Args::try_parse_from(["agenix", "-q", "decrypt", "secret.age"]).unwrap();
        assert!(args.quiet);
        if let Some(Command::Decrypt { file, .. }) = args.command {
            assert_eq!(file, "secret.age");
        } else {
            panic!("Expected Decrypt command");
        }
    }

    #[test]
    fn test_quiet_with_check() {
        let args = Args::try_parse_from(["agenix", "-q", "check"]).unwrap();
        assert!(args.quiet);
        assert!(matches!(args.command, Some(Command::Check { .. })));
    }

    #[test]
    fn test_quiet_verbose_conflict() {
        // --quiet and --verbose should conflict
        let result = Args::try_parse_from(["agenix", "-q", "-v", "list"]);
        assert!(result.is_err(), "Should conflict: quiet and verbose");
    }

    #[test]
    fn test_verbose_quiet_conflict() {
        // Order shouldn't matter
        let result = Args::try_parse_from(["agenix", "-v", "-q", "list"]);
        assert!(result.is_err(), "Should conflict: verbose and quiet");
    }

    #[test]
    fn test_quiet_with_all_global_flags() {
        let args = Args::try_parse_from([
            "agenix",
            "-q",
            "--secrets-nix",
            "/secrets.nix",
            "-i",
            "/key",
            "--no-system-identities",
            "list",
        ])
        .unwrap();
        assert!(args.quiet);
        assert!(!args.verbose);
        assert_eq!(args.secrets_nix, "/secrets.nix");
        assert_eq!(args.identity, vec!["/key".to_string()]);
        assert!(args.no_system_identities);
    }

    // ===========================================
    // EDITOR OPTIONAL TESTS
    // ===========================================

    #[test]
    fn test_edit_no_editor_when_env_not_set() {
        with_env_var("EDITOR", None, || {
            let args = Args::try_parse_from(["agenix", "edit", "test.age"]).unwrap();
            if let Some(Command::Edit { editor, .. }) = args.command {
                assert_eq!(editor, None);
            } else {
                panic!("Expected Edit command");
            }
        });
    }

    #[test]
    fn test_edit_explicit_editor_overrides_none() {
        with_env_var("EDITOR", None, || {
            let args = Args::try_parse_from(["agenix", "edit", "-e", "emacs", "test.age"]).unwrap();
            if let Some(Command::Edit { editor, .. }) = args.command {
                assert_eq!(editor, Some("emacs".to_string()));
            } else {
                panic!("Expected Edit command");
            }
        });
    }

    #[test]
    fn test_edit_env_editor_is_used() {
        with_env_var("EDITOR", Some("helix"), || {
            let args = Args::try_parse_from(["agenix", "edit", "test.age"]).unwrap();
            if let Some(Command::Edit { editor, .. }) = args.command {
                assert_eq!(editor, Some("helix".to_string()));
            } else {
                panic!("Expected Edit command");
            }
        });
    }
}
