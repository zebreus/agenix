= AGENIX(1)
:doctype: manpage
:manmanual: Agenix Manual
:mansource: agenix {revnumber}
:man-linkstyle: pass:[blue R < >]
:revnumber: 0.1.0

== NAME

agenix - edit and rekey age secret files

== SYNOPSIS

*agenix* [_GLOBAL-OPTIONS_] _COMMAND_ [_COMMAND-OPTIONS_] [_ARGUMENTS_]

*agenix* [*-r* _RULES_] [*-i* _IDENTITY_]... *edit* [*-e* _EDITOR_] [*-f*] _SECRET_

*agenix* [*-r* _RULES_] *encrypt* [*--input* _FILE_] [*-f*] _SECRET_

*agenix* [*-r* _RULES_] [*-i* _IDENTITY_]... *decrypt* [*-o* _FILE_] _SECRET_

*agenix* [*-r* _RULES_] [*-i* _IDENTITY_]... *rekey* [*-p*] [_SECRET_]...

*agenix* [*-r* _RULES_] *generate* [*-f*] [*--no-dependencies*] [_SECRET_]...

*agenix* [*-r* _RULES_] [*-i* _IDENTITY_]... *list* [*-s*] [_SECRET_]...

*agenix* [*-r* _RULES_] [*-i* _IDENTITY_]... *check* [_SECRET_]...

*agenix* *completions* _SHELL_

== DESCRIPTION

*agenix* is a command-line tool for managing secrets encrypted with age. It uses a Nix expression (typically `secrets.nix`) to define which public keys can decrypt each secret.

Secrets are encrypted using SSH keys or age keys, making it easy to use existing SSH infrastructure for secret management in NixOS configurations.

== GLOBAL OPTIONS

These options can be used with any command.

*-r*, *--rules* _FILE_::
  Path to the Nix rules file defining secrets and their recipients. Default: `./secrets.nix`. Can also be set via the *RULES* environment variable.

*-i*, *--identity* _KEY_::
  Identities to use when decrypting. Can be specified multiple times. Identities are tried in order: explicitly specified first, then default system identities (*~/.ssh/id_ed25519*, *~/.ssh/id_rsa*).

*--no-system-identities*::
  Do not use default system identities. Only use identities specified with *-i*.

*-n*, *--dry-run*::
  Show what would be done without making changes.

*-v*, *--verbose*::
  Show detailed information about operations.

*-q*, *--quiet*::
  Suppress non-essential output.

*-h*, *--help*::
  Print help information.

*-V*, *--version*::
  Print version information.

== COMMANDS

*edit*, *e* _SECRET_::
  Edit a secret file using *$EDITOR*. Creates a new file if it doesn't exist. The file is decrypted to a temporary location, opened in the editor, then re-encrypted when saved. If decryption fails with the available identities, use *--force* to start with empty content.
  +
  Command options:::
    *-e*, *--editor* _COMMAND_::::
      Editor command to use. Defaults to *$EDITOR*, or *vi* if unset.
    *-f*, *--force*::::
      Open an empty editor if decryption fails with the available identities. Useful for recreating a secret when you no longer have access to decrypt it.

*encrypt*, *c* _SECRET_::
  Encrypt content from standard input (or a file) to a secret file. The secret must be defined in the rules file.
  +
  Command options:::
    *--input* _FILE_::::
      Read content from a file instead of standard input.
    *-f*, *--force*::::
      Overwrite an existing secret file.

*decrypt*, *d* _SECRET_::
  Decrypt a secret file to standard output or a file. Fails if the secret cannot be decrypted with the available identities.
  +
  Command options:::
    *-o*, *--output* _FILE_::::
      Write decrypted output to a file instead of standard output.

*rekey*, *r* [_SECRET_]...::
  Re-encrypt secrets with updated recipients from the rules file. If no secrets are specified, rekeys all secrets. Without *--partial*, fails without modifying any files if any requested secret cannot be decrypted with the available identities.
  +
  Command options:::
    *-p*, *--partial*::::
      Skip secrets that cannot be decrypted instead of failing. Only decryptable secrets are rekeyed.

*generate*, *g* [_SECRET_]...::
  Generate secrets using generator functions defined in the rules file. If no secrets are specified, generates all secrets that have generators.
  +
  Command options:::
    *-f*, *--force*::::
      Overwrite existing secret files.
    *--no-dependencies*::::
      Do not automatically generate dependencies of specified secrets.

*list*, *l* [_SECRET_]...::
  List secrets defined in the rules file. If secrets are specified, lists only those secrets.
  +
  Command options:::
    *-s*, *--status*::::
      Show status of each secret (ok, missing, or cannot decrypt with available identities).

*check*, *v* [_SECRET_]...::
  Verify that secrets can be decrypted with the available identities without outputting their content. Returns success if all specified secrets (or all secrets if none specified) can be decrypted.

*completions* _SHELL_::
  Generate shell completions. Supported shells: *bash*, *zsh*, *fish*, *elvish*, *powershell*.

== EXIT STATUS

*0*::
  Success.

*1*::
  General error (for example, file not found, decryption failed).

*2*::
  Command-line usage error.

== ENVIRONMENT

*EDITOR*::
  Editor to use when editing secrets. Default: *vi*.

*RULES*::
  Path to the Nix rules file. Default: `./secrets.nix`.

== FILES

*secrets.nix*::
  The default rules file defining secrets and their recipients. See *Rules file format* in the *NOTES* section.

*~/.ssh/id_ed25519*, *~/.ssh/id_rsa*::
  Default identity files used for decryption.

== NOTES

=== Non-interactive mode

When standard input is not a terminal (for example, when piping), the *edit* command reads content from standard input instead of opening an editor. This allows scripted secret creation:

  *echo "secret-value" | agenix edit secret.age*

=== Rekeying

When you change the recipients in `secrets.nix`, you must rekey your secrets:

  *agenix rekey*

Due to randomness in age's encryption, files always change when rekeyed, even if recipients remain the same.

=== Rules file format

The rules file (typically `secrets.nix`) is a Nix expression that evaluates to an attribute set. Each key is a secret filename (usually ending in `.age`) and each value is a secret configuration.

==== Basic structure

[source,nix]
----
let
  user1 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5...";
  system1 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5...";
in {
  "secret.age".publicKeys = [ user1 system1 ];
  "other.age".publicKeys = [ user1 ];
}
----

==== Secret attributes

*publicKeys* (required)::
  List of public keys that can decrypt this secret. Supports SSH keys (`ssh-ed25519`, `ssh-rsa`), age keys (`age1...`), and references to other secrets' public keys by name.

*armor* (optional)::
  When `true`, use ASCII-armored format instead of binary. Default: `false`.

*generator* (optional)::
  A function to generate the secret value. See *Generator functions*.

*dependencies* (optional)::
  List of other secret names whose values can be accessed in the generator function.

==== Public key references

Instead of a literal public key, you can reference another secret's `.pub` file by name:

[source,nix]
----
{
  "deploy-key.age" = {
    publicKeys = [ user1 ];
    generator = builtins.sshKey;
  };
  "config.age".publicKeys = [ user1 "deploy-key" ];
}
----

When encrypting `config.age`, agenix reads `deploy-key.age.pub` and uses that public key.

=== Generator functions

Generator functions create secret values automatically when running *agenix generate*.

==== Function signature

Generators are Nix functions that accept an attribute set and return either:

* A string (creates only the `.age` file)
* An attrset `{ secret, public }` (creates both `.age` and `.pub` files)

The function argument can contain:

*{ }*::
  No parameters needed.

*{ publics }*::
  Attribute set of public content from dependencies (from `.pub` files).

*{ secrets }*::
  Attribute set of decrypted secret content from dependencies (only available during generation).

*{ secrets, publics }*::
  Both of the above.

==== Evaluation

Generators are evaluated by the agenix CLI at generation time, not by Nix itself. The CLI provides additional builtins that are not available in standard Nix.

Dependencies are resolved automatically: if secret A depends on secret B, B is generated first. If B already has a `.pub` file, that file is used without regenerating B.

==== Built-in generator functions

The following functions are provided by agenix and available as `builtins.*`:

*builtins.randomString* _LENGTH_::
  Random alphanumeric string of the specified length.

*builtins.randomHex* _LENGTH_::
  Random hexadecimal string (lowercase) of the specified length.

*builtins.randomBase64* _BYTES_::
  Random base64-encoded string from the specified number of random bytes.

*builtins.passwordSafe* _LENGTH_::
  Random password using alphanumeric characters plus `-_+=.`.

*builtins.uuid*, *builtins.uuid {}*::
  Random UUIDv4 string.

*builtins.sshKey*, *builtins.sshKey {}*::
  SSH Ed25519 keypair. Returns `{ secret, public }`.

*builtins.rsaKey*, *builtins.rsaKey {}*, *builtins.rsaKey { keySize = N; }*::
  SSH RSA keypair. Optional `keySize`: 2048, 3072, or 4096 (default: 4096). Returns `{ secret, public }`.

*builtins.ageKey*, *builtins.ageKey {}*::
  age x25519 keypair. Returns `{ secret, public }`.

*builtins.blake2b* _STRING_::
  BLAKE2b-512 hash of the string (128 hex characters).

*builtins.blake2s* _STRING_::
  BLAKE2s-256 hash of the string (64 hex characters).

*builtins.keccak* _STRING_::
  SHA3-256 (Keccak) hash of the string (64 hex characters).

==== Automatic generator selection

When no explicit `generator` is specified, agenix selects one based on the filename:

[cols="1,2"]
|===
|Filename Pattern |Generator

|`*ed25519.age`, `*ssh.age`, `*ssh_key.age`
|`builtins.sshKey` (SSH Ed25519 keypair)

|`*x25519.age`
|`builtins.ageKey` (age keypair)

|`*password.age`, `*passphrase.age`
|`builtins.randomString 32`
|===

==== Generator examples

Simple password:

[source,nix]
----
{
  "api-token.age" = {
    publicKeys = [ user1 ];
    generator = { }: builtins.randomString 32;
  };
}
----

SSH keypair with public key output:

[source,nix]
----
{
  "deploy-key.age" = {
    publicKeys = [ user1 ];
    generator = builtins.sshKey;
  };
}
----

Derived secret using dependency:

[source,nix]
----
{
  "ca-key.age" = {
    publicKeys = [ user1 ];
    generator = builtins.sshKey;
  };
  "host-cert.age" = {
    publicKeys = [ user1 ];
    dependencies = [ "ca-key" ];
    generator = { publics }: "signed by: ${publics."ca-key"}";
  };
}
----

== EXAMPLES

Edit or create a secret:

  *agenix edit secret.age*

Encrypt from standard input:

  *echo "my-password" | agenix encrypt secret.age*

  *cat plaintext.txt | agenix encrypt --force secret.age*

Encrypt from a file:

  *agenix encrypt --input plaintext.txt secret.age*

Decrypt to standard output:

  *agenix decrypt secret.age*

Decrypt to a file:

  *agenix decrypt secret.age -o plaintext.txt*

Re-encrypt all secrets after changing recipients:

  *agenix rekey*

Re-encrypt specific secrets:

  *agenix rekey secret1.age secret2.age*

Re-encrypt only secrets you can decrypt:

  *agenix rekey --partial*

Generate all secrets with generators:

  *agenix generate*

Preview what would be generated:

  *agenix generate --dry-run*

Generate specific secret and its dependencies:

  *agenix generate my-key.age*

List all defined secrets:

  *agenix list*

List specific secrets:

  *agenix list secret1.age secret2.age*

List secrets with status:

  *agenix list --status*

Verify secrets can be decrypted:

  *agenix check*

Use a custom rules file:

  *agenix -r /path/to/secrets.nix edit secret.age*

Use a specific identity:

  *agenix -i ~/.ssh/other_key decrypt secret.age*

Generate shell completions:

  *agenix completions bash > ~/.local/share/bash-completion/completions/agenix*

  *agenix completions zsh > ~/.zfunc/_agenix*

  *agenix completions fish > ~/.config/fish/completions/agenix.fish*

== SEE ALSO

*age*(1), *ssh-keygen*(1)
